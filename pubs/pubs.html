<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

<head>
<title>Publications</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="bibtex2html">
<link rel=stylesheet type="text/css" href="../css/desktop.css">
</head>

<body>

<!-- This document was automatically generated with bibtex2html 1.98
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     /usr/bin/bibtex2html -css ../css/desktop.css -t Publications -d -r pubs.bib  -->

<h1>Publications</h1>
<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="amirmoh-kari-lsfa20">1</a>]
</td>
<td class="bibtexitem">
Sepehr Amir-Mohammadian and Chadi Kari.
 Correct audit logging in concurrent systems.
 <em>Electronic Notes in Theoretical Computer Science</em>, 351:115--141,
  September 2020.
 Part of Special Issue: Proceedings of LSFA 2020, the 15th
  International Workshop on Logical and Semantic Frameworks, with Applications.
[&nbsp;<a href="pubs_bib.html#amirmoh-kari-lsfa20">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1016/j.entcs.2020.08.007">DOI</a>&nbsp;| 
<a href="https://sepehram.github.io/pubs/lsfa20.pdf">.pdf</a>&nbsp;]
<blockquote>
Audit logging provides post-facto analysis of runtime behavior for 
		different purposes, including error detection, amelioration of system 
		operations, and the establishment of security in depth. This necessitates 
		some level of assurance on the quality of the generated audit logs, i.e., 
		how well the audit log represents the events transpired during the execution. 
		Information-algebraic techniques have been proposed to formally specify this 
		relation and provide a framework to study correct audit log generation in a 
		provable fashion. However, previous work fall short on how to guarantee this 
		property of audit logging in concurrent environments. In this paper, we study 
		an implementation model in a concurrent environment. We propose an algorithm 
		that instruments a concurrent system according to a formal  specification of 
		audit logging requirements, so that any instrumented concurrent system 
		guarantees correct audit log generation. As an application, we consider systems 
		with microservices architecture, where logging an event by a microservice is 
		conditioned on the occurrence of a collection of events that take place in 
		other microservices of the system.
</blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="skalka-amirmoh-clark-jcs20">2</a>]
</td>
<td class="bibtexitem">
Christian Skalka, Sepehr Amir-Mohammadian, and Samuel Clark.
 Maybe tainted data: Theory and a case study.
 <em>Journal of Computer Security</em>, 28(3):295--335, April 2020.
[&nbsp;<a href="pubs_bib.html#skalka-amirmoh-clark-jcs20">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.3233/JCS-191342">DOI</a>&nbsp;| 
<a href="https://sepehram.github.io/pubs/jcs20.pdf">.pdf</a>&nbsp;]
<blockquote>
Dynamic taint analysis is often used as a defense against 
		low-integrity data in applications with untrusted user interfaces. 
		An important example is defense against XSS and injection attacks 
		in programs with web interfaces. Data sanitization is commonly used 
		in this context, and can be treated as a precondition for endorsement 
		in a dynamic integrity taint analysis. However, sanitization is often 
		incomplete in practice. We develop a model of dynamic integrity taint 
		analysis for Java that addresses imperfect sanitization with an in-depth 
		approach. To avoid false positives, results of sanitization are endorsed 
		for access control (aka prospective security), but are tracked and logged 
		for auditing and accountability (aka retrospective security). We show how 
		this heterogeneous prospective/retrospective mechanism can be specified 
		as a uniform policy, separate from code. We then use this policy to 
		establish correctness conditions for a program rewriting algorithm that 
		instruments code for the analysis. These conditions synergize our previous 
		work on the semantics of audit logging with explicit integrity which is an 
		analogue of noninterference for taint analysis. A technical contribution of 
		our work is the extension of explicit integrity to a high-level functional 
		language setting with structured data, vs. previous systems that only address 
		low level languages with unstructured data. Our approach considers endorsement 
		which is crucial to address sanitization. An implementation of our rewriting 
		algorithm is presented that hardens the OpenMRS medical records software system 
		with in-depth taint analysis, along with an empirical evaluation of the overhead 
		imposed by instrumentation. Our results show that this instrumentation is 
		practical.
</blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="kari-chen-amirmoh-vivek-icnc19">3</a>]
</td>
<td class="bibtexitem">
Chadi Kari, Sixia Chen, Sepehr Amir-Mohammadian, and Vivek&nbsp;K. Pallipuram.
 Data migration in large scale heterogeneous storage systems with
  nodes to spare.
 In <em>International Conference on Computing, Networking and
  Communications, ICNC 2019, Honolulu, HI, USA, February 18-21, 2019</em>.
  IEEE, February 2019.
[&nbsp;<a href="pubs_bib.html#kari-chen-amirmoh-vivek-icnc19">bib</a>&nbsp;| 
<a href="https://sepehram.github.io/pubs/icnc19.pdf">.pdf</a>&nbsp;]
<blockquote>
In large scale storage systems such as data centers,  the layout of data 
		on storage disks needs to be frequently reconfigured  for load 
		balancing purposes or in the event of system failure/upgrades. 
		This reconfiguration event, referred to as <i>data migration</i>, 
		must be completed efficiently as the system tends to perform sub-optimally 
		during such process. The data-migration problem has been studied extensively 
		in the literature with efficient algorithms presented for  homogeneous 
		(all storage disks have similar capabilities)  and heterogeneous 
		(storage disks can have different capabilities) cases. <p>
		In this paper, we investigate adding <i>data forwarding</i> to existing 
		algorithms for the heterogeneous data migration problem. In data forwarding, 
		we introduce additional storage nodes (called bypass nodes) during the 
		migration process. Our simulations show that  adding as few as 2 bypass 
		nodes with limited capabilities can improve the performance by up to 15% 
		and adding more bypass nodes with heterogeneous capabilities can improve 
		the migration performance by 25%. We then present a novel algorithm that 
		makes intrinsic use of bypass nodes and show that the algorithm can always 
		achieve an optimal migration schedule while adding no more than 
		 &alpha;&#215;<em>n</em>/3 bypass nodes where <em>n</em> is the numbers of disks and 
		&alpha; is a term defined to reflect the heterogeneity factor of disks.
</blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="amirmoh-phd-thesis">4</a>]
</td>
<td class="bibtexitem">
Sepehr Amir-Mohammadian.
 <em>A Formal Approach to Combining Prospective and Retrospective
  Security</em>.
 PhD thesis, The University of Vermont, July 2017.
[&nbsp;<a href="pubs_bib.html#amirmoh-phd-thesis">bib</a>&nbsp;| 
<a href="https://sepehram.github.io/pubs/thesis.pdf">.pdf</a>&nbsp;]
<blockquote>
The major goal of this dissertation is to enhance software security by 
		provably correct enforcement of in-depth policies. In-depth security 
		policies allude to heterogeneous specification of security strategies 
		that are required to be followed <i>before</i> and <i>after</i> 
		sensitive operations. Prospective security is the enforcement of 
		security, or detection of security violations before the execution of 
		sensitive operations, e.g., in authorization, authentication and 
		information flow. Retrospective security refers to security checks 
		after the execution of sensitive operations, which is accomplished 
		through accountability and deterrence. Retrospective security frameworks 
		are built upon <em>auditing</em> in order to provide sufficient evidence 
		to hold users accountable for their actions and potentially support 
		other remediation actions. Correctness and efficiency of audit logs play 
		significant roles in reaching the accountability goals that are required 
		by retrospective, and consequently, in-depth security policies. This 
		dissertation addresses correct audit logging in a formal framework.<p>
		Leveraging retrospective controls beside the existing prospective 
		measures enhances security in numerous applications. This dissertation 
		focuses on two major application spaces for in-depth enforcement. The 
		first is to enhance prospective security through surveillance and 
		accountability. For example, authorization mechanisms could be improved 
		by guaranteed retrospective checks in environments where there is a 
		high cost of access denial, e.g., healthcare systems. The second 
		application space is the amelioration of potentially flawed prospective 
		measures through retrospective checks. For instance, erroneous 
		implementations of input sanitization methods expose vulnerabilities in 
		taint analysis tools that enforce direct flow of data integrity policies. 
		In this regard, we propose an in-depth enforcement framework to mitigate 
		such problems. We also propose a general semantic notion of explicit flow 
		of information integrity in a high-level language with sanitization. <p>
		This dissertation studies the ways by which prospective and retrospective 
		security could be enforced uniformly in a provably correct manner to handle 
		security challenges in legacy systems. Provable correctness of our results 
		relies on the formal Programming Languages-based approach that we have 
		taken in order to provide software security assurance. Moreover, this 
		dissertation includes the implementation of such in-depth enforcement 
		mechanisms for a medical records web application.
</blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="amirmoh-skalka-plas16">5</a>]
</td>
<td class="bibtexitem">
Sepehr Amir-Mohammadian and Christian Skalka.
 In-depth enforcement of dynamic integrity taint analysis.
 In <em>Proceedings of the 2016 ACM Workshop on Programming Languages
  and Analysis for Security (PLAS)</em>, October 2016.
[&nbsp;<a href="pubs_bib.html#amirmoh-skalka-plas16">bib</a>&nbsp;| 
<a href="https://sepehram.github.io/pubs/plas16.pdf">.pdf</a>&nbsp;]
<blockquote>
Dynamic taint analysis can be used as a defense against 
    		low-integrity data in applications with untrusted user interfaces.  
    		An important example is defense against XSS and injection attacks 
    		in programs with web interfaces. Data sanitization is commonly used 
    		in this context,  and can be treated as a precondition for endorsement 
    		in a dynamic integrity taint analysis.  However, sanitization is often 
    		incomplete in practice.  We develop a model of dynamic integrity taint 
    		analysis for Java that addresses imperfect sanitization with an in-depth 
    		approach.  To avoid false positives, results of sanitization are endorsed 
    		for access control (aka prospective security), but are tracked and logged 
    		for auditing and accountability (aka retrospective security). We show how 
    		this heterogeneous prospective/retrospective mechanism can be specified 
    		as a uniform policy, separate from code.  We then use this policy to 
    		establish correctness conditions for a program rewriting algorithm that 
    		instruments code for the analysis.  The rewriting itself is a model of 
    		existing, efficient Java taint analysis tools.
</blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="amirmoh-chong-skalka-post16">6</a>]
</td>
<td class="bibtexitem">
Sepehr Amir-Mohammadian, Stephen Chong, and Christian Skalka.
 Correct audit logging: Theory and practice.
 In <em>International Conference on Principles of Security and Trust
  (POST)</em>. Springer, April 2016.
[&nbsp;<a href="pubs_bib.html#amirmoh-chong-skalka-post16">bib</a>&nbsp;| 
<a href="https://sepehram.github.io/pubs/post16.pdf">.pdf</a>&nbsp;]
<blockquote>
Retrospective security has become increasingly important to the
    		 theory and practice of cyber security, with auditing a crucial component
    		 of it. However, in systems where auditing is used, programs are 
    		 typically instrumented to generate audit logs using manual, ad-hoc 
    		 strategies. This is a potential source of error even if log analysis 
    		 techniques are formal, since the relation of the log itself to program 
    		 execution is unclear. This paper focuses on provably correct program 
    		 rewriting algorithms for instrumenting formal logging specifications. 
    		 Correctness guarantees that the execution of an instrumented program 
    		 produces sound and complete audit logs, properties defined by an 
    		 information containment relation between logs and the program's logging 
    		 semantics. We also propose a program rewriting approach to 
    		 instrumentation for audit log generation, in a manner that guarantees 
    		 correct log generation even for untrusted programs. As a case study, we 
    		 develop such a tool for OpenMRS, a popular medical records management 
    		 system, and consider instrumentation of break the glass policies.
</blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="amirmoh-chong-skalka-law15">7</a>]
</td>
<td class="bibtexitem">
Sepehr Amir-Mohammadian, Stephen Chong, and Christian Skalka.
 Foundations for auditing assurance.
 In <em>Layered Assurance Workshop (LAW)</em>, December 2015.
[&nbsp;<a href="pubs_bib.html#amirmoh-chong-skalka-law15">bib</a>&nbsp;| 
<a href="https://sepehram.github.io/pubs/law15.pdf">.pdf</a>&nbsp;]
<blockquote>
Retrospective security is an important element of layered 
    security systems. Auditing is central to the theory and practice of 
    retrospective security, however, in systems where auditing is used, 
    programs are typically instrumented to generate audit logs using manual, 
    ad-hoc strategies. This is a potential source of error even if log auditing
    techniques are formal, since the relation of the log itself to program 
    execution is unclear.  This paper focuses on provably correct program 
    rewriting algorithms for instrumenting formal logging specifications. 
    Correctness guarantees that execution of an instrumented program produces 
    sound and complete audit logs,  properties defined by an information 
    containment relation between logs and the program's logging semantics. As 
    an application example, we consider auditing for break the glass policies, 
    wherein authorization is replaced by auditing in emergency conditions.
</blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="amirmoh-chong-skalka-tr15">8</a>]
</td>
<td class="bibtexitem">
Sepehr Amir-Mohammadian, Stephen Chong, and Christian Skalka.
 The theory and practice of correct audit logging.
 Technical report, University of Vermont, October 2015.
[&nbsp;<a href="pubs_bib.html#amirmoh-chong-skalka-tr15">bib</a>&nbsp;| 
<a href="https://sepehram.github.io/pubs/tr15.pdf">.pdf</a>&nbsp;]
<blockquote>
Auditing has become increasingly important to the theory and 
	    practice of cyber security. However, in systems where auditing is used, 
	    programs are typically instrumented to generate audit logs using manual,
	    ad-hoc strategies. This is a potential source of error even if log  
	    auditing techniques are formal, since the relation of the log itself to 
	    program execution is unclear. This work focuses on provably correct 
	    program rewriting algorithms for instrumenting formal logging 
	    specifications.  Correctness guarantees that the execution of an 
	    instrumented program produces sound and complete audit logs, properties 
	    defined by an information containment relation between logs and the 
	    program's logging semantics.  Logging semantics is sufficiently general, 
	    so that the guarantees extend to various approaches of audit logging. As a
	    case study, we demonstrate the incorporation of the proposed techniques 
	    and features in healthcare informatics. In particular, we consider 
	    auditing for break the glass policies, wherein authorization is replaced 
	    by auditing in emergency conditions.
</blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="amirmoh-fallah-clss13">9</a>]
</td>
<td class="bibtexitem">
Sepehr Amir-Mohammadian and Mehran&nbsp;S. Fallah.
 Noninterference in a predicative polymorphic calculus for access
  control.
 <em>Computer Languages, Systems &amp; Structures</em>, 39(3):109--120,
  October 2013.
[&nbsp;<a href="pubs_bib.html#amirmoh-fallah-clss13">bib</a>&nbsp;| 
<a href="https://sepehram.github.io/pubs/clss13.pdf">.pdf</a>&nbsp;]
<blockquote>
Polymorphic programming languages have been adapted for 
    		constructing distributed access control systems, where a program represents
	    a proof of eligibility according to a given policy.  As a security 
    		requirement, it is typically stated that the programs of such languages 
	    should satisfy noninterference. However, this property has not been defined 
    		and proven semantically.  In this paper, we first propose a semantics based 
	    on Henkin models for a predicative polymorphic access control language 
    		based on lambda-calculus. A formal semantic definition of noninterference 
	    is then proposed through logical relations.  We prove a type soundness 
    		theorem which states that any well-typed program of our language meets the
	    noninterference property defined in this paper.  In this way, it is 
    		guaranteed that access requests from an entity do not interfere with those 
	    from unrelated or more trusted entities.
</blockquote>
<p>
</td>
</tr>
</table><hr><p><em>This file was generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.98.</em></p>
</body>
</html>
